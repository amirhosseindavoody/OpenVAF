use std::ffi::CStr;
use std::io::Write;
use std::os::raw::c_char;
use std::panic::catch_unwind;
use std::slice;
use std::time::Instant;
use std::{fs, path::Path};

use anyhow::{bail, Context, Result};
use basedb::{lints::LintLevel, BaseDB};
use camino::{Utf8Path, Utf8PathBuf};
use libc::c_void;
use libloading::Library;
use linker::link;
use llvm::OptLevel;
use log::{debug, error, info, warn};
use mir_llvm::LLVMBackend;
use paths::AbsPathBuf;
use sim_back::CompilationDB;
use target::spec::Target;
use termcolor::{Color, ColorChoice, ColorSpec, StandardStream, WriteColor};

use crate::devices::DeviceImpl;
use crate::veriloga::osdi_0_3::{
    OsdiDescriptor, LOG_FMT_ERR, LOG_LVL_DEBUG, LOG_LVL_DISPLAY, LOG_LVL_ERR, LOG_LVL_FATAL,
    LOG_LVL_INFO, LOG_LVL_MASK, LOG_LVL_WARN,
};
use crate::veriloga::osdi_device::OsdiDevice;

pub(crate) use osdi_0_3::{
    ANALYSIS_AC, ANALYSIS_DC, ANALYSIS_IC, ANALYSIS_NOISE, ANALYSIS_STATIC, ANALYSIS_TRAN,
    CALC_NOISE, CALC_REACT_JACOBIAN, CALC_REACT_RESIDUAL, CALC_RESIST_JACOBIAN,
    CALC_RESIST_RESIDUAL,
};

mod cache;
// autogenerated
#[allow(warnings)]
mod osdi_0_3;
mod osdi_device;

#[derive(Default)]
pub struct Opts {
    pub defines: Vec<String>,
    pub codegen_opts: Vec<String>,
    pub cache_dir: Option<Utf8PathBuf>,
    pub lints: Vec<(String, LintLevel)>,
    include: Vec<AbsPathBuf>,
    pub opt_lvl: Option<OptLevel>,
}

impl Opts {
    pub fn add_include_dir(&mut self, dir: &Utf8Path) -> Result<()> {
        self.include.push(AbsPathBuf::assert(dir.canonicalize()?));
        Ok(())
    }
}

fn recompile(
    path: &Utf8Path,
    db: &CompilationDB,
    start: Instant,
    dst: Utf8PathBuf,
    opts: &Opts,
) -> Result<()> {
    fs::create_dir_all(dst.parent().unwrap()).context("failed to create cache directory")?;

    let modules = if let Some(modules) = db.collect_modules() {
        modules
    } else {
        bail!("openvaf: compilation of {path} failed")
    };
    let target = Target::host_target().context("target is not supported by openvaf")?;
    let back = LLVMBackend::new(&opts.codegen_opts, &target, "native".to_owned(), &[]);
    let paths = osdi::compile(
        db,
        &modules,
        dst.as_ref(),
        &target,
        &back,
        true,
        opts.opt_lvl.unwrap_or(OptLevel::Aggressive),
    );
    link(&target, dst.as_ref(), |linker| {
        for path in &paths {
            linker.add_object(path);
        }
    })?;

    for obj_file in paths {
        std::fs::remove_file(obj_file).context("failed to delete intermediate compile artifact")?;
    }

    let seconds = Instant::elapsed(&start).as_secs_f64();
    let mut stderr = StandardStream::stderr(ColorChoice::Auto);
    stderr.set_color(ColorSpec::new().set_fg(Some(Color::Green)).set_bold(true))?;
    write!(&mut stderr, "Finished")?;
    stderr.set_color(&ColorSpec::new())?;
    writeln!(&mut stderr, " building {} in {:.2}s", path.file_name().unwrap(), seconds)?;

    Ok(())
}
pub fn compile_va(path: &Utf8Path, opts: &Opts) -> Result<Vec<Box<dyn DeviceImpl>>> {
    let input = path.canonicalize().with_context(|| format!("failed to resolve {path}"))?;
    let input = AbsPathBuf::assert(input);

    let cache_dir = if let Some(dir) = &opts.cache_dir {
        dir.clone()
    } else {
        let path = directories_next::ProjectDirs::from("com", "semimod", "melange")
            .context("failed to find cache directory\nhelp: consider setting it manually")?
            .cache_dir()
            .to_owned();
        if let Ok(path) = Utf8PathBuf::from_path_buf(path) {
            path
        } else {
            bail!("failed to find cache directory\nhelp: consider setting it manually")
        }
    };
    let start = Instant::now();
    let db = CompilationDB::new(input, &opts.include, &opts.defines, &opts.lints)?;
    if !db.preprocess(db.root_file).diagnostics.is_empty() {
        db.collect_modules();

        bail!("openvaf: compilation of {path} failed");
    }

    let (lib_file, exists) = cache::lookup(&db, &opts.defines, &cache_dir);
    if !exists {
        recompile(path, &db, start, lib_file.clone(), opts)?;
    }
    // SAFETY: library is loaded as a trusted file that is assumed to adhere to the OSDI spec    let res = unsafe {
    let res = unsafe {
        load_osdi_lib(lib_file.as_ref()).with_context(|| format!("failed to load {}", lib_file))?
    };

    Ok(res.iter().map(|descriptor| Box::new(OsdiDevice { descriptor }) as _).collect())
}

unsafe fn load_osdi_lib(path: &Path) -> Result<&'static [OsdiDescriptor]> {
    let lib = Library::new(path)?;
    let lib = Box::leak(Box::new(lib));

    let major_version: &u32 = *lib.get(b"OSDI_VERSION_MAJOR\0")?;
    let minor_version: &u32 = *lib.get(b"OSDI_VERSION_MINOR\0")?;

    if *major_version != 0 || *minor_version != 3 {
        bail!(
            "melange only supports OSDI v0.3 but {} targets v{major_version}.{minor_version}",
            path.display()
        );
    }

    let num_descriptors: &u32 = *lib.get(b"OSDI_NUM_DESCRIPTORS\0")?;
    let descriptors: *const OsdiDescriptor = *lib.get(b"OSDI_DESCRIPTORS\0")?;

    let descriptors: &[OsdiDescriptor] =
        slice::from_raw_parts(descriptors, *num_descriptors as usize);

    if let Ok(osdi_log_ptr) =
        lib.get::<*mut unsafe fn(*mut c_void, *const c_char, u32)>(b"osdi_log\0")
    {
        osdi_log_ptr.write(osdi_log)
    }
    Ok(descriptors)
}

unsafe fn osdi_log(handle: *mut c_void, msg: *const c_char, lvl: u32) {
    let _ = catch_unwind(|| osdi_log_impl(handle, msg, lvl));
}

unsafe fn osdi_log_impl(handle: *mut c_void, msg: *const c_char, lvl: u32) {
    let instance = handle as *const c_char;
    let instance = CStr::from_ptr(instance).to_str().expect("all OSDI strings must be valid utf-8");
    let msg = CStr::from_ptr(msg).to_str().expect("all OSDI strings must be valid utf-8");

    if (lvl & LOG_FMT_ERR) == 0 {
        match lvl & LOG_LVL_MASK {
            LOG_LVL_DEBUG => debug!("{instance} - {msg}"),
            LOG_LVL_DISPLAY => print!("{instance} - {msg}"),
            LOG_LVL_INFO => info!("{instance} - {msg}"),
            LOG_LVL_WARN => warn!("{instance} - {msg}"),
            LOG_LVL_ERR => error!("{instance} - {msg}"),
            LOG_LVL_FATAL => error!("{instance} - FATAL {msg}"),
            _ => error!("{instance} - UNKOWN_LOG_LVL {msg}"),
        }
    } else {
        match lvl & LOG_LVL_MASK {
            LOG_LVL_DEBUG => debug!("{instance} - failed to format\"{msg}\""),
            LOG_LVL_DISPLAY => println!("{instance} - failed to format\"{msg}\""),
            LOG_LVL_INFO => info!("{instance} - failed to format\"{msg}\""),
            LOG_LVL_WARN => warn!("{instance} - failed to format\"{msg}\""),
            LOG_LVL_ERR => error!("{instance} - failed to format\"{msg}\""),
            LOG_LVL_FATAL => error!("{instance} - FATAL failed to format\"{msg}\""),
            _ => error!("{instance} - UNKOWN_LOG_LVL failed to format\"{msg}\""),
        }
    }
}
